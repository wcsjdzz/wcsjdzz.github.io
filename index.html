<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Blooooog~ - 你所不知道的老杜振熙之技术博客</title><meta name="author" content="老杜振熙"><meta name="copyright" content="老杜振熙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="或许在此处可以找到你我想要的东西">
<meta property="og:type" content="website">
<meta property="og:title" content="Blooooog~">
<meta property="og:url" content="https://wcsjdzz.github.io/index.html">
<meta property="og:site_name" content="Blooooog~">
<meta property="og:description" content="或许在此处可以找到你我想要的东西">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wcsjdzz.github.io/null">
<meta property="article:author" content="老杜振熙">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wcsjdzz.github.io/null"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wcsjdzz.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: true,
  isToc: false,
  postUpdate: '2021-07-06 13:41:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Blooooog~</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="site-info"><h1 id="site-title">Blooooog~</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/03/14/Linux-Useful-Command-Argument-Combination/" title="Linux - Useful Command Argument Combination">     <img class="post_bg" src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux - Useful Command Argument Combination"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/03/14/Linux-Useful-Command-Argument-Combination/" title="Linux - Useful Command Argument Combination">Linux - Useful Command Argument Combination</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-03-14T15:07:05.000Z" title="发表于 2021-03-14 23:07:05">2021-03-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/OS/">OS</a></span></div><div class="content">ps
ps -ef：显示所有进程的信息；
ps l：输出进程的额外信息，包括 STAT 状态信息（XY，X 代表当前状态，分别有：S 睡眠，R 就绪，O 运行；Y 代表额外的状态信息，如下图所示），比如 Ss 代表该进程处于睡眠状态，并且是一个控制进程；

du
du -h -d1：显示当前文件夹下所有子文件和子文件夹所占用的空间（注意，递归深度只有 1）

</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/03/08/MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" title="MySQL子查询优化">     <img class="post_bg" src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL子查询优化"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/03/08/MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" title="MySQL子查询优化">MySQL子查询优化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-03-08T13:04:14.000Z" title="发表于 2021-03-08 21:04:14">2021-03-08</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">子查询优化概述和分类
子查询在外层查询中可能出现的位置：
在 select 中：SELECT (SELECT MAX(COL1) FROM TABLE1);
在 from 中：SELECT M1 FROM (SELECT M+1 FROM TABLE1 WHERE M&gt;2) AS TMP;
在 WHERE 中（最常见）：SELECT * FROM TABLE1 WHERE M1 IN (SELECT M2 FROM TABLE2)；


按照子查询返回的数据的规模，将子查询分类如下：
标量子查询；行子查询；列子查询；表子查询；


按照与外层查询的关系进行分类：
不相关子查询：子查询可以独立运行得到结果；
相关子查询：依赖外部查询的结果；SELECT * FROM T1 WHERE T1.M1 IN (SELECT T2.M2 IN T2 WHERE T1.N1 = T2.N2)



限制条件由于子查询一般只是用在 where 中，以构成操作数 comparison_operator (子查询)，所以这里列举一下这种情况下的一些限制条件：

comparison_operato ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/03/08/mysql-grammer-summary/" title="mysql-grammer-summary">     <img class="post_bg" src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql-grammer-summary"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/03/08/mysql-grammer-summary/" title="mysql-grammer-summary">mysql-grammer-summary</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-03-08T13:04:14.000Z" title="发表于 2021-03-08 21:04:14">2021-03-08</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">former
use &lt;database&gt; : 选择某个数据库
测试: 不加 FROM 字段可以测试 mysql 的各个功能
DELIMITER &lt;character&gt;: 自定义新的分隔符（以替换掉;分隔符）

常用的 SHOW 命令SHOW DATABASES:SHOW TABLES:SHOW COLUMNS FROM &lt;TABLE&gt; 等价于 DESCRIBE &lt;TABLE&gt;SHOW GRANTS
常用的 SELECT 命令SELECT &lt;COLUMNS&gt; FROM &lt;TABLE&gt; : 从表中选出某一列（整列）SELECT DISTINCT &lt;COLUMNS&gt; FROM &lt;TABLE&gt; : 从表中选出某一整列，但剔除掉重复的行SELECT &lt;COLUMNS&gt; FROM &lt;TABLE&gt; LIMIT &lt;row, lines&gt; : 选出从第 row 行开始的 lines 行SELECT &lt;TABLES&gt;.&lt;COLUMNS&gt; FROM & ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/01/27/Brief-Notes-of-%E3%80%8AEffective-C-%E3%80%8B/" title="Brief Notes of 《Effective C++》">     <img class="post_bg" src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Brief Notes of 《Effective C++》"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/01/27/Brief-Notes-of-%E3%80%8AEffective-C-%E3%80%8B/" title="Brief Notes of 《Effective C++》">Brief Notes of 《Effective C++》</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-27T14:13:41.000Z" title="发表于 2021-01-27 22:13:41">2021-01-27</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Deep-in-C/">Deep in C++</a></span></div><div class="content">本文为学习《Effective C++》各个条款之后的一点概要式的总结。
条款 2 尽量以 const, enum, inline 替代#define
宁可用编译器替代预处理器。以#define 定义的记号是不会记录到符号表中的；
#define 没有封装性可言。
enum hack。enum &#123;tmp=5&#125;;对应的tmp一定在编译器就可以得到并且不会导致非必要的内存分配。

条款 3 尽可能使用 const
调用 const 成员函数以实现孪生 non-const 成员函数。通过使用const_cast和static_cast来达到目的，优点是避免了代码重复。
调用 non-const 成员函数实现 const 成员函数是错误的。因为这破坏了 const 的语义约束。

条款 5 了解 C++默认编写并调用哪些函数
如果自定义了需要实参的构造函数，则编译器不会自动生成 default ctor
如果 class 内部包含有带有&amp;引用类型或者const常量类型，则编译器不会自动生成 copy assignment；因为编译器不知道该怎么处理

条款 7 为多 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2021/01/04/TCP-summary/" title="TCP-summary">     <img class="post_bg" src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TCP-summary"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/01/04/TCP-summary/" title="TCP-summary">TCP-summary</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-04T12:56:40.000Z" title="发表于 2021-01-04 20:56:40">2021-01-04</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Computer-Network/">Computer Network</a></span></div><div class="content">前言
面向连接的、可靠的字节流服务:

必须先连接，再交互数据；
TCP 不对发送的字节流做任何解释和标识符插入;


TCP 连接：

socket: 编程接口，一个 IP 地址和一个端口号唯一标志一个 socket
($2^{32}-1$): TCP 字节流的最大序号，循环反复; 每个被传输的字节都被计数
流量控制：每一端对窗口大小进行声明; 起始于确认序号字段指明的值(默认为 4096)


TCP 头部

2 字节源端口号+2 字节目的端口号；
4 字节序号
4 字节确认序号
{4 位首部长度，保留 6 位，6 位标志位}+2 字节窗口大小
2 字节检验和+2 字节紧急指针
可选选项


一些注意点：

TCP 中仅有两方进行通信，广播和多播不能用于 TCP
应用层数据会被 TCP 分割成合适的数据块，称为报文段（segment）
TCP 首部最长为 60 字节（4 位首部长度最大值为 15，单位为 4 字节，故最长为$4\times15=60$）




TCP 连接建立和终止
tcpdump:

格式：源 &gt; 目的：标志(&#123;&#39;S&#39;, &#39 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2021/01/04/C-%E5%B9%B6%E5%8F%91API%E6%80%BB%E7%BB%93/" title="C++并发API总结">     <img class="post_bg" src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++并发API总结"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/01/04/C-%E5%B9%B6%E5%8F%91API%E6%80%BB%E7%BB%93/" title="C++并发API总结">C++并发API总结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-04T12:53:30.000Z" title="发表于 2021-01-04 20:53:30">2021-01-04</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Deep-in-C/">Deep in C++</a></span></div><div class="content">本文是阅读《Effective Modern C++》之后的一点理解和笔记github 博客地址
基于线程 VS. 基于任务1234int doAsyncWork();std::thread t(doAsyncWork); // 基于线程auto fut = std::async(doAsyncWork); // 基于任务


硬件线程：实际执行计算的线程，和实际的 CPU 核心有关（一个核心对应一个或多个硬件线程）；

软件线程：进行进程管理、硬件线程调度的线程；系统能够提供的软件线程有限；

超订（oversubscription）：就绪状态的软件线程超过了硬件线程个数；

软件线程和硬件线程的最佳比例很难确定，因为它取决于：

软件线程变为可运行状态的频繁程度（IO 密集型 VS. 计算密集型）
上下文切换的开销成本（与体系结构有关）
软件线程使用 CPU 缓存的命中率（与体系结构有关）
…


std::thread：底层软件线程的句柄

在通常情况下，基于任务会比基于线程更好，原因如下：

std::async的返回值类型std::future拥有get()成员函数，可以方便 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/12/26/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/" title="滑动窗口最大值">     <img class="post_bg" src="/2020/12/26/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/%E7%A4%BA%E4%BE%8B.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="滑动窗口最大值"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/12/26/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/" title="滑动窗口最大值">滑动窗口最大值</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-26T11:43:18.000Z" title="发表于 2020-12-26 19:43:18">2020-12-26</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Algorithm/">Algorithm</a></span></div><div class="content">问题描述如下图所示，长度为k的滑动窗口在数组中从左往右移动，求出在移动过程中，窗口中的最大值的集合。(窗口的长度不长于数组长度)

初步解法——使用优先队列考虑示例中的nums[1]，显然可知的是，nums[1]作为最大值的有效窗口只能是区间[0, 2]和[1, 3]，一旦某个时刻的窗口起始位置大于了最大值x的位置，那么x就不再有效了。
由于最大值的判定和位置十分相关，所以我们在记录最大值的时候，也很有必要将它的位置一并记录下来，如下所示：
1using Pir = pair&lt;int, int&gt;; // &lt;元素值，元素位置&gt;

接下来就是思考有哪些数据结构可以在低于线性复杂度的情况下找到最值。优先队列就是其中的一种。重点来了，本题适合选用优先队列的原因就在于：对于固定的一个最值x，其服务的窗口区间仅仅是离他最近的那些区间。倘若在某一个时刻我们发现，当前的窗口区间对于最值x已经不再有效，那么对于之后时刻的窗口区间更加不会有效。故之前将其舍弃即可。
讲到这里，优先队列的解法也就很明了了。
123456789101112131415161718192021class  ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/12/26/%E4%BB%85%E5%8C%85%E5%90%AB%E5%85%83%E7%B4%A01%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/" title="仅包含元素1的最大矩形面积">     <img class="post_bg" src="/2020/12/25/%E4%BB%85%E5%8C%85%E5%90%AB%E5%85%83%E7%B4%A01%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="仅包含元素1的最大矩形面积"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/12/26/%E4%BB%85%E5%8C%85%E5%90%AB%E5%85%83%E7%B4%A01%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/" title="仅包含元素1的最大矩形面积">仅包含元素1的最大矩形面积</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-26T02:47:32.000Z" title="发表于 2020-12-26 10:47:32">2020-12-26</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/Algorithm/">Algorithm</a></span></div><div class="content">问题描述如图所示的仅包含 0，1 元素的二维数组，找出最大的矩形面积。矩形需要满足：内部元素全为 1 (图中的最大矩形面积显然为 6)

问题分析先将问题转化为这样一个问题：柱状图的最大矩阵面积，如下图示意。显然，对于该图而言，最大矩形面积为 10
如何解决柱状图的最大矩形面积问题呢？我们需要从图中找到规律。
首先可以明确：最大矩形面积肯定不小于每个柱体的面积，因此，我们先找到一个方法去计算最大柱体的面积。最简单的方法肯定就是直接去遍历柱体的高度呗。但这样不具有普遍性，因为对于柱体连接之后所构成的更大的矩形，就不能用这种方法去计算了。
还是以该图举例。对于柱体 6，我们发现其两旁的柱体都低于 6，因此对于该柱体的面积，就等于两边柱体的距离(柱体 5 和柱体 2 的距离)乘以该柱体的高度。
可这个方法对于柱体 5 而言呢？其两旁比它低的柱体分别是柱体 1 和柱体 2，按照这个方法算出来恰好就是我们想要的答案 10！
我们需要一个理由和理解来对这个方法进行支撑。思考之后，给出这样的断言：
计算一个柱状图的最大矩形面积，等价于柱状图的宽度乘以柱状图中最低的柱体
可能有人会问了，拿上图来举例， ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/2020/12/22/%E7%94%A8time-wheel%E8%B8%A2%E6%8E%89%E7%A9%BA%E9%97%B2TCP%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%A5%BD%E4%BE%8B%E5%AD%90/" title="用time wheel踢掉空闲TCP连接——使用C++智能指针的好例子">     <img class="post_bg" src="/2020/12/22/%E7%94%A8time-wheel%E8%B8%A2%E6%8E%89%E7%A9%BA%E9%97%B2TCP%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%A5%BD%E4%BE%8B%E5%AD%90/pic1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用time wheel踢掉空闲TCP连接——使用C++智能指针的好例子"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/12/22/%E7%94%A8time-wheel%E8%B8%A2%E6%8E%89%E7%A9%BA%E9%97%B2TCP%E8%BF%9E%E6%8E%A5%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%A5%BD%E4%BE%8B%E5%AD%90/" title="用time wheel踢掉空闲TCP连接——使用C++智能指针的好例子">用time wheel踢掉空闲TCP连接——使用C++智能指针的好例子</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-22T10:11:52.000Z" title="发表于 2020-12-22 18:11:52">2020-12-22</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/C-net-programming/">C++ net programming</a></span></div><div class="content">注：本文为阅读《Linux 多线程服务端编程：使用 muduo C++网络库》的一点笔记
空闲连接指的是一段时间内没有受到任何数据的连接。我们需要做的是每隔一段时间断开这些空闲连接，以免浪费资源。剔除空闲连接这一任务大概有如下两个特点和需求：

无需精准定时：只需要一个大致的间隔，比如说 10s 左右未受到数据，则判定其为空闲连接
应尽量简单：剔除空闲连接应该是一个简洁明了的操作，不应占据太多的计算或空间资源

time wheel 运用了桶排序的思路，在系统中设置 N 个桶，共同组成一个队列。第 i 个桶中存放 i 秒后将要变为空闲连接的连接。这样一来，我们只需要每秒剔除第 0 个桶中的连接即可，无需遍历全部连接，剔除之后，将第 0 个桶移动到尾部。而一个连接如果接收到了新数据，那么该连接就将自己重新放入最后一个桶中。
接下来，我先用自己的语言描述一下书中作者所使用的数据结构：

桶中存放TcpConnection？: 我们在断掉连接之前还需要判断其是否还处于连接状态，结合 RAII 技术，使用using Entry = std::weak_ptr&lt;TcpConnection& ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/2020/12/20/%E4%BD%BF%E7%94%A8std-chrono%E5%BA%93%E6%9E%84%E5%BB%BA%E6%97%B6%E9%97%B4%E6%88%B3/" title="使用std::chrono库构建时间戳">     <img class="post_bg" src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用std::chrono库构建时间戳"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/12/20/%E4%BD%BF%E7%94%A8std-chrono%E5%BA%93%E6%9E%84%E5%BB%BA%E6%97%B6%E9%97%B4%E6%88%B3/" title="使用std::chrono库构建时间戳">使用std::chrono库构建时间戳</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-20T13:50:09.000Z" title="发表于 2020-12-20 21:50:09">2020-12-20</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox article-meta__icon"></i><a class="article-meta__categories" href="/categories/C-net-programming/">C++ net programming</a></span></div><div class="content">前言 - std::chrono 的用法三种主要类型
clocks: 包括一个起始点(epoch)以及一个变动率(tick rate)
time point: 自特定 clock 的 epoch 之后经过的 duration
duration: 指时间跨度，包括衡量跨度的时间单位以及有多少个单位(count of ticks)

关于 clock 的用法
steady_clock和system_clock的区别：

前者绝对单调，不可调整；后者基于真实系统时钟，不一定单调；
前者更适合测量 time interval；后者是唯一可以转换为 c-style time(std::time_t)的 clock 类型；


使用 clock 记录时间点以及函数执行用时不同的时钟类型都拥有一个函数now()来指示当前的时刻


123456789101112131415161718192021// 使用std::chrono库记录函数执行用时#include &lt;chrono&gt;#include &lt;iostream&gt;using namespace std::chrono;in ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">老杜振熙</div><div class="author-info__description">或许在此处可以找到你我想要的东西</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wcsjdzz"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">Next plan - http server based on net library</div></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/03/14/Linux-Useful-Command-Argument-Combination/" title="Linux - Useful Command Argument Combination"><img src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux - Useful Command Argument Combination"/></a><div class="content"><a class="title" href="/2021/03/14/Linux-Useful-Command-Argument-Combination/" title="Linux - Useful Command Argument Combination">Linux - Useful Command Argument Combination</a><time datetime="2021-03-14T15:07:05.000Z" title="发表于 2021-03-14 23:07:05">2021-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/08/MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" title="MySQL子查询优化"><img src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL子查询优化"/></a><div class="content"><a class="title" href="/2021/03/08/MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" title="MySQL子查询优化">MySQL子查询优化</a><time datetime="2021-03-08T13:04:14.000Z" title="发表于 2021-03-08 21:04:14">2021-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/08/mysql-grammer-summary/" title="mysql-grammer-summary"><img src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql-grammer-summary"/></a><div class="content"><a class="title" href="/2021/03/08/mysql-grammer-summary/" title="mysql-grammer-summary">mysql-grammer-summary</a><time datetime="2021-03-08T13:04:14.000Z" title="发表于 2021-03-08 21:04:14">2021-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/27/Brief-Notes-of-%E3%80%8AEffective-C-%E3%80%8B/" title="Brief Notes of 《Effective C++》"><img src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Brief Notes of 《Effective C++》"/></a><div class="content"><a class="title" href="/2021/01/27/Brief-Notes-of-%E3%80%8AEffective-C-%E3%80%8B/" title="Brief Notes of 《Effective C++》">Brief Notes of 《Effective C++》</a><time datetime="2021-01-27T14:13:41.000Z" title="发表于 2021-01-27 22:13:41">2021-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/04/TCP-summary/" title="TCP-summary"><img src="/img/doc-cover.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TCP-summary"/></a><div class="content"><a class="title" href="/2021/01/04/TCP-summary/" title="TCP-summary">TCP-summary</a><time datetime="2021-01-04T12:56:40.000Z" title="发表于 2021-01-04 20:56:40">2021-01-04</time></div></div></div></div></div><div class="card-widget card-categories"><div class="card-content"><div class="item-headline"><i class="fas fa-folder-open"></i><span>分类</span></div><ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Algorithm/"><span class="card-category-list-name">Algorithm</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C-net-programming/"><span class="card-category-list-name">C++ net programming</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Computer-Network/"><span class="card-category-list-name">Computer Network</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Deep-in-C/"><span class="card-category-list-name">Deep in C++</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/MySQL/"><span class="card-category-list-name">MySQL</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/OS/"><span class="card-category-list-name">OS</span><span class="card-category-list-count">1</span></a></li>
            
            </ul></div></div><div class="card-widget card-archives"><div class="card-content"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/03/"><span class="card-archive-list-date">三月 2021</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/01/"><span class="card-archive-list-date">一月 2021</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/12/"><span class="card-archive-list-date">十二月 2020</span><span class="card-archive-list-count">13</span></a></li></ul></div></div><div class="card-widget card-webinfo"><div class="card-content"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">19</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2021-07-06T05:41:29.483Z"></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 老杜振熙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>